# 前言

本篇记录使用到的C++知识。

## 虚函数

​		在C++语言中，当我们使用基类的**引用或者指针**调用一个**虚成员函数**时，会进行**动态绑定**。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以**所有虚函数都必须有定义**。

​		OOP的核心思想就是多态性，我们把具有继承关系的多个类型称为**多态类型**，同时引用或指针的**静态类型与动态类型不同**这个事实，正是C++语言支持多态性的根本存在。

​		当我们在派生类中覆盖了某个虚函数时，可以再一次使用`virtual`关键字指出该函数的性质，然而这么做并非必须，因为一旦某个函数被声明为虚函数，则**在派生类中它都是虚函数**。

## override

​		和`Java`和`Kotlin`类似，如果子类重写了父类中的抽象方法，一般加上一个`override`关键字，来进行说明。在C++ 11中就提供了这么个关键字，我们可以在派生类中用`override`来**说明派生类中的虚函数**，作用：

1. 可以使得程序员的意图更加清晰；

2. 可以让编译器为我们发现一些错误，如果使用`override`标记了某个函数，但是该函数没有覆盖已存在的虚函数，则编译器会报错。

## 抽象基类

​		可以在函数体的位置(**声明语句的分号之前**)书写` = 0`，将一个虚函数说明为**纯虚函数**。含有纯虚函数的类为**抽象基类**，抽象基类负责**定义接口**，后续的其他类可以覆盖该接口，不能直接创建一个抽象基类的对象。

## `Q_INVOKEABLE` 关键字

​		`Q_INVOKEABLE`是Qt中的一个关键字，用于在C++中声明一个成员函数可以从`QML`中调用。即使用`Q_INVOKEABLE`修饰的成员函数，可以被`QML`中的代码作为一个可调用项使用(类似`JavaScript`函数)，这使得开发者**可以在`QML`中直接调用C++的成员函数**。

​		使用`Q_INVOKEABLE`时，需要注意下面几点：

- 被修饰的函数必须是类的成员函数而非静态函数；
- 被修饰的函数必须是公有函数；
- 被修饰的函数不能是虚函数；
- 被修饰的函数的参数和返回值必须是Qt数据类型或者`QVariant`类型；
- 被修饰的函数不能接收或返回用户自定义类型的指针，但是可以将用户自定义类型放入`QVariant`中传递。

使用`Q_INVOKABLE`修饰的函数通常定义在`QML`显示的数据模型中，以便`QML`界面能够直接调用数据模型相应的成员函数对数据进行处理。

## 预处理

​		预处理阶段编程的**操作目标是"源码"**，用各种预处理指令控制预处理器，把**源码改造成另一种形式**。C++的关键字非常多，但是预处理指令很少，常用的也就`#include`、`#define`、`#if`，下面来简单说几点：

- 预处理指令**都以`#`开头**，虽然都在一个源文件中，它不属于C++语言，**走的是预处理器**，**不受C++语法规则约束**。
- 预处理指令不应该受C++代码缩进影响，不论在哪里，永远都**定格写**。
- 单独一个`#`也是一个预处理指令，叫做空指令，可以当做特别的预处理空行。而且`#`与后面的指令直接也可以有空格，从而可以**实现缩进**。
- 预处理程序无法调试，可以**使用`GCC`的`-E`选项**，来输出预处理后的源码。

```C++
#
#if __linux__
#	define HAS_LINUX 1
#endif
#
```

## `#include`

​		`#include`预处理指令的作用是**包含文件**，而**不是包含头文件**，是**可以包含任意文件**。只要愿意，可以把源码、文本，甚至图片都包含进来。所以`#include`功能很弱，只知道把数据合并进源文件。

​		这也是为什么我们在写头文件时，**需要加上"Include Guard"机制**代码，来防止头文件被重复包含。

```C++
#ifndef H_INCLUDED_
#define H_INCLUDED_
... //头文件内容
#endif
```

​		除了包含头文件，还可以利用`#include`	实现**代码片段共享**，比如我们可以把一些数据片段放入一个`.inc`文件中，然后使用`#include`实现源码级别的功能抽象。

```c++
static u32 table[] = {
# include "x.inc"	//隐藏了细节
}
```

## `.inc`文件

​		在C++中，`.inc`文件没有特定的类型或规定，一般来说，`.inc`文件是**用于包含实现代码的文件**，不同于`.h`和`.cpp`文件。`.h`文件通常定义C++类或函数的声明，这些声明提供了类或函数的名称、参数和返回类型等信息。而`.cpp`文件则包含这些声明所对应的函数实现。

​		`.inc`文件与之类似，但通常将其用于实现C++模板类或关联函数，由于编译器的限制，也无法被编译。所以通常`.inc`被看成一种辅助文件，提供一种共享代码的方式，比如上面配合`#include`的使用。

## 宏定义`(#define/#undef)`

​		使用`#define`可以定义一个源码级别的"文本替换"，也就是宏定义。`#define`功能非常强大，在预处理阶段可以无视C++语法限制，进行替换任何文字，定义常量/变量，实现函数功能，减少重复代码等等。

​		也由于宏太灵活，使用宏时一定要谨慎，时刻记者以简化代码、清晰易懂为目的，不能滥用，导致代码难以阅读。下面有几点注意事项：

1. 宏的展开和替换发生在预处理阶段，不涉及函数调用、参数传递、指针寻址，没有任何运行时期效率损失。所以对于经常调用的小代码片段，使用宏来封装比inline关键字更好，这时真正源码级别的内联。
2. 宏是没有作用域概念的，永远都是全局有效。所以对于一些用来简化代码、起临时作用的宏，最好在用完之后使用`#undef`取消宏定义。
3. 另一种做法是宏定义前先检查，如果之前有定义，就先进行`undef`，然后再重新定义。
4. 适当使用宏定义可以消除代码中的常量，消除"魔数数字"、"魔数字符串"。

## 条件编译`(#if/#else#endif)`

​		记住预处理器的精髓，它是用来**处理源码的**，所以利用前面`#define`定义的各种宏，我们可以在预处理阶段**实现分支处理**，通过判断宏的数值，**来产生不同的源码**，从而改变源文件的形态，这就是"**条件编译**"。	

​		条件编译有2个重点，一个是条件指令`#if`，另一个是后面的判断依据，也就是定义好的各种宏，而这个判断依据是条件编译中非常关键的部分。

​		既然是预处理阶段，所以**通常在编译环境中会预定义一些宏**，这样预处理器就可以在预处理阶段对源码做处理，从而产生符合当前系统或者编译器等的源码。比如有一个宏是`__cplusplus`，它标记了C++语言版本号，我们可以使用它来判断当前是C还是C++，比如下面代码：

```C++
#ifdef __cplusplus
	extern "C" {
#endif
	void a_c_func();
#ifdef __cplusplus
    }
#endif
```

​		这段代码不太容易理解，假如定义了`__cplusplus`，则说明是用C+编译，这时需要按照C的方式去处理，就需要添加`extern "C"`，否则就不添加。所以这里使用了2处判断，**按照是否是C++编译会生成2种源码**，这就是源码级的条件编译。

## C++数组不能作为函数返回值

​		数组类型在C/C++的世界中，只能是"二等公民"，只可以用在栈变量和结构体/类中的字段，而不能用在函数的返回值上，用在函数参数上也容易造成误解。

​		这不是技术原因，更像是C语言设计失误。C是一种简单的语言，当初为了语言使用方便，有2个简化行为：函数会变成函数指针，数组会变成元素的指针。现在来看，这种设计是有问题的，但是在C这样的简单语言中，这种规则可以带来方便，只是C++为了兼容性，就继承了这些规则。

​		还有一个角度为什么解释了C++为什么不能返回数组。因为数组不能直接拷贝，C++函数能返回对象，要不对象分配在堆里面，要不会生成一个临时对象，才可以返回。而对于返回值和指针，可以直接通过寄存器返回。对于数组而言，没有拷贝构造函数，不方便返回。

## C++数组不能直接拷贝赋值

​		这里的直接拷贝赋值是使用`=`符号来进行是不允许的。比如`int a[2] = {1,2};`和`int b[2] = {3,4};`，这里的`a`和`b`的类型是`int *const`常量指针类型，常量是不能对其进行赋值的。

​		理解这句话要明白前面所说的，数组会退化为元素指针，同时常量指针是无法重新赋值。同时我们应该知道，数组的拷贝用其他方式可以，但是这种直接`a = b`的方式不行，不是技术原因，而是历史原因。		

## C++ `const`简析

​		C++中的`const`，表示"常量"，最常用的用法是定义程序用到的数字、字符串常量，代替宏定义，比如下面代码：

```C++
const int MAX = 1024;
const string NAME = "petor";
```

从C++程序的生命周期来看，它和宏有着本质区别：`const`定义的常量在预处理阶段并不存在，而是知道运行阶段才会出现。

​		所以，它其实是运行时的"变量"，只是不能修改，**是"只读"的(read only)**，所以`const`常量**叫做"只读变量"其实更合适**。

## 顶层`const`和底层`const`

​		由于指针本身是一个对象，它又指向另一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量就是2个互相独立的问题。用名词**顶层`const`表示指针本身是一个常量**，而用名词**底层`const`表示指针所指的对象是一个常量**。

​		有着更一般的定义，**顶层`const`可以表示任意的对象是常量**，对任何数据类型都适用，比如算术类型、类、指针等。而**底层`const`只和指针和引用等复合类型的基本类型部分有关**。但是指针，既可以是顶层`const`，也可以是底层`const`。

​		更难的点，是关于这2种`const`的书写形式，常见如下：

```C++
int i = 0;
const int ci = 42;		//对于非引用、非指针类型来说，这一定是一个顶层const
int *const p1 = &i;		//对于指针类型来说，当const在*的右边，表示指针是一个常量，也是顶层const
const int *p2 = &ci;	//而const写在正常的位置，表示这是一个指向常量的指针，即是一个底层const
const int *const p3 = p2;	//靠右的是顶层const，靠左的是底层const
const int &r = ci;		//由于引用是非对象，所以引用的const都是底层const
```

​		正常来说，我们的书写形式都是`const`放在类型前面，对于值类型来说，就表示值本身只读，是顶层`const`，而对于指针和引用来说，这也是最正常的用，指向只读变量的指针或绑定到只读变量的引用。

​		只有一种写法比较奇特，就是`const`写在`*`后面，表示指针自己是只读的。

## `const` 拷贝注意事项

​		理解这一点非常关键，因为函数的参数和返回值都涉及到拷贝，而且还和函数重载有关。对于顶层`const`来说，几乎不受什么影响：

```C++
i = ci;		//正确操作，拷贝ci的值，ci是一个顶层const，拷贝无影响
p2 = p3;	//正确操作，这里p2和p3都是指向只读int的指针，虽然p3是顶层const，也不影响
```

​		但是对于底层`const`则不能忽略，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层`const`资格，或者可以转换：

```
int *p = p3;	//错误，p3包含底层const，而p没有
p2 = p3;		//正确，p2和p3都是底层const
p2 = &i;		//正确，int*能转换成const int*
int &r = ci;	//错误，普通的int引用不能绑定到int常量上
const int &r2 = i;	//正确，const int&可以绑定到一个普通的int上
```

​		这里的转换，有一个非常有意思的理解：所谓指向常量的指针或者引用，不过是指针或者引用的"自以为是"罢了，它们觉得自己指向了常量，所以直觉地不去改变所指对象的值。

## 函数重载和`const`形参

​		说点实际使用的，根据前面理解，对于一个顶层`const`来说，它不会影响传入函数的对象，即一个拥有顶层`const`的形参无法和一个没有顶层`const`的形参区分开来，比如下面代码：

```C++
Record lookup(Phone)；
Record lookup(const Phone)； 	//重复声明
```

​		我们可以想象一下，调用该函数时，会发生值拷贝，即把实参拷贝给形参来完成初始化，拷贝完后这个形参`phone`在其作用域中改不改变，其实是无所谓的，所以这2个函数是重复声明。同时，指针也可以是顶层`const`，如下：

```C++
Record lookup(Phone*);
Record loopup(Phone* const)；	//重复声明
```

​		一样的道理，在函数调用时也是发生值拷贝，拷贝进来一份地址数据，而对于形参来说，它自己的值(即地址)可不可以改变，其实是无所谓的，所以是重复声明。

​		而如果形参引用或者指针，则可以通过区分其指向的是常量对象还是非常量对象可以实现函数重载，这时的`const`是底层的。比如下面代码：

```C++
Record lookup(Account&);			//函数作用于Account的引用
Record lookup(const Account&);		//函数作用于常量引用
Record lookup(Account*);			//作用于指向Account的指针
Record lookup(const Account*)；		//作用于指向常量的指针
```

​		记住一个原则，函数实参和形参的初始化规则和之前变量初始化规则一样。首先就是我们不能把一个常量引用赋值给一个非常量的引用，这样函数可以修改这个常量，明显不符合常理。其次，我们也不能把一个常量指针赋值给一个非常量指针，这样的话在函数内，可以通过这个非常量指针可以修改常量，也是不符合常理。

​		所以，上面4个重载函数都是对的。还有一点需要注意，虽然`const`不能转换成其他类型，我们只能把`const`对象(或者指向`const`的指针)传递给`const`形参，但是非常量可以转换成`const`，即上面4个函数都可以作用于非常量对象或指向非常量对象的指针。不过，当我们传递一个非常量或者指向非常量对象的指针时，编译器会有限选用非常量版本的函数。

## `const_cast`简析

​		`const_cast`**只能**改变运算对象的**底层`const`**，而底层`const`不外乎就是指针和引用，这是一种"去掉`const`性质"的行为，一旦我们去掉了某个对象的`const`性质，我们就可以对对象进行写操作了。

​		这个特性很奇怪，既然要去掉底层`const`，在开始声明时，不加不就可以了？对于底层`const`是想去就去吗？会不会导致错误？

​		首先，如果一个对象本身就是常量，再使用`const_cast`执行写操作会产生未定义的后果。这句话就有点反常识，比如下面代码：

```C++
const int k = 10;
int& x = const_cast<int>(k);
x = 11;
```

这就是典型的问题代码，是未定义行为。`const_cast`的目的是某些变量原本不是`const`的，但是由于某种特殊原因，变成了`const`的，比如下面代码：

```C++
int k = 10;
const int& ref = k;
int& x = const_cast<int>(ref);
x = 11;
```

在这种情况下，代码才是可以正常执行的。

## 重载和`const_cast`

​		`const_cast`的使用场景非常少，其中一个就是重载。前面说了，对于底层`const`类型不同的参数，是可以重载函数的，比如有下面函数：

```C++
const string &shorterString(const string &s1, const string &s2){
	return s1.size() <= s2.size() ? s1 : s2;
}
```

​		由于是比较字符串长度，我们并不需要修改字符串，所以这个函数的参数和返回值类型都是`const string`的引用。但是当我们对2个非常量的`string`调用该函数时，根据非常量可以转成`const`，这里依旧可以调用，并且返回还是`const string`的引用。

​		这种结果有一点不太好，因此我们需要一种新的`shorterString`函数，当实参不是常量时，得到一个普通引用，这时我们可以使用`const_cast`来实现：

```C++
string &shorterString(string &s1, string &s2){
    auto &r = shorterString(const_cast<const string&>(s1),
                           const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

​		在这个实现中，首先把非`const`类型的实参转换为`const string &`类型，注意这里是增加其底层`const`特性，然后返回`const string`类型的引用，最后再转换为非常量引用。这里之所以不会出错，是因为我们知道这里的`s1`和`s2`原来就是非`const`的，即使对函数结果进行去`const`行为也是正确的。

​		`const_cast`核心点还是**只能处理对象的底层`const`**，且是在预期之内。
